<script>
    const container = document.getElementById('brain-viewport');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.z = 6;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0x4040ff, 0.4));
    const pointLight = new THREE.PointLight(0x00ffff, 1.5);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    let brain;
    let targetX = 0, targetY = 0; // Posição do mouse
    const loader = new THREE.GLTFLoader();

    loader.load('human-brain.glb', (gltf) => {
        brain = gltf.scene;
        brain.scale.set(1.1, 1.1, 1.1);
        brain.traverse(c => {
            if (c.isMesh) {
                c.material = new THREE.MeshStandardMaterial({
                    color: 0x000510,
                    emissive: 0xe30613,
                    emissiveIntensity: 0.4,
                    roughness: 0.8,
                    metalness: 0.1
                });
            }
        });
        scene.add(brain);
    });

    // Rastreamento suave do mouse
    window.addEventListener('mousemove', (e) => {
        // Normaliza as coordenadas de -0.3 a 0.3 (para ser um movimento leve)
        targetX = (e.clientX / window.innerWidth - 0.5) * 0.6;
        targetY = (e.clientY / window.innerHeight - 0.5) * 0.6;
    });

    document.getElementById('idInput').addEventListener('input', () => {
        if (brain) {
            brain.traverse(c => {
                if (c.isMesh) {
                    c.material.emissive.setHex(0x00ffff);
                    c.material.emissiveIntensity = 10.0;
                }
            });
        }
    });

    function animate() {
        requestAnimationFrame(animate);
        if (brain) {
            // 1. Rotação Automática Lenta (Auto-giro)
            brain.rotation.y += 0.005;

            // 2. Adiciona a inclinação do mouse de forma bem leve (Interpolação)
            // Somamos o targetX à rotação Y para não anular o giro automático
            brain.rotation.z += 0.05 * (targetX - brain.rotation.z);
            brain.rotation.x += 0.05 * (targetY - brain.rotation.x);

            brain.traverse(c => {
                if (c.isMesh && c.material.emissiveIntensity > 0.4) {
                    c.material.emissiveIntensity *= 0.91;
                    if (c.material.emissiveIntensity < 2.5) {
                        c.material.emissive.setHex(0xe30613);
                    }
                }
            });
        }
        renderer.render(scene, camera);
    }
    animate();

    function validarAcesso() {
        const val = document.getElementById('idInput').value.toUpperCase();
        if (val === "MATH001" || val.startsWith("PAC")) window.location.href = "unt.html";
        else alert("ID INVÁLIDO");
    }

    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
